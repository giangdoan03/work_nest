<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>PDF Auto Sign (HCNS) + OCR fallback</title>

    <!-- pdf.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- pdf-lib -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- Tesseract.js (OCR) -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.1/dist/tesseract.min.js"></script>

    <style>
        :root {
            --bg: #0f172a;
            --muted: #1e293b;
            --ink: #e2e8f0;
            --accent: #22d3ee;
            --line: #334155;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font: 14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
        }

        header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: linear-gradient(180deg, rgba(15, 23, 42, .98), rgba(15, 23, 42, .92));
            backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--line);
        }

        .wrap {
            max-width: 1100px;
            margin: 0 auto;
            padding: 16px;
        }

        h1 {
            font-size: 18px;
            margin: 0 0 6px;
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .card {
            background: var(--muted);
            border: 1px solid var(--line);
            border-radius: 14px;
            padding: 12px;
        }

        label.btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            border: 1px dashed var(--line);
            border-radius: 10px;
            cursor: pointer;
        }

        input[type="file"] {
            display: none;
        }

        button {
            appearance: none;
            border: 1px solid var(--line);
            background: #0b1220;
            color: var(--ink);
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
        }

        button.primary {
            border-color: transparent;
            background: linear-gradient(90deg, #06b6d4, #22d3ee);
            color: #0b1220;
            font-weight: 700;
        }

        button:disabled {
            opacity: .5;
            cursor: not-allowed;
        }

        .tools {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tools input[type="text"],
        .tools input[type="number"],
        .tools select {
            background: #0b1220;
            color: var(--ink);
            border: 1px solid var(--line);
            border-radius: 8px;
            padding: 8px;
        }

        .canvasWrap {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 12px;
            margin: 16px 0;
        }

        .right {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .hint {
            opacity: .8;
            font-size: 12px;
        }

        canvas {
            width: 100%;
            height: auto;
            max-width: 900px;
            background: white;
            border-radius: 8px;
            border: 1px solid var(--line);
        }

        .list {
            max-height: 360px;
            overflow: auto;
            border: 1px solid var(--line);
            border-radius: 10px;
        }

        .listItem {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            padding: 8px;
            border-bottom: 1px dashed var(--line);
        }

        .badge {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 6px;
            background: #0b1220;
            border: 1px solid var(--line);
        }

        .radio {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            padding: 6px 10px;
            border: 1px solid var(--line);
            border-radius: 10px;
        }

        .radio input {
            margin: 0;
        }

        .footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 12px 0;
        }

        a.link {
            color: var(--accent);
            text-decoration: none;
        }

        .pill {
            padding: 4px 8px;
            border: 1px solid var(--line);
            border-radius: 999px;
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }
    </style>
</head>

<body>
<header>
    <div class="wrap">
        <h1>PDF Auto Sign ‚Äî K√Ω v√†o m·ªçi ‚ÄúHCNS‚Äù (c√≥ OCR)</h1>

        <div class="row">
            <label class="btn"><input id="pdfInput" type="file"
                                      accept="application/pdf"/><span>üìÑ Ch·ªçn PDF‚Ä¶</span></label>

            <!-- nhi·ªÅu ·∫£nh ch·ªØ k√Ω -->
            <label class="btn" title="PNG/JPG, c√≥ th·ªÉ ch·ªçn nhi·ªÅu; n√™n PNG n·ªÅn trong su·ªët">
                <input id="imgInput" type="file" accept="image/*" multiple/>
                <span>üñºÔ∏è Ch·ªçn ·∫£nh ch·ªØ k√Ω (nhi·ªÅu)</span>
            </label>

            <span id="pageInfo" class="pill">Trang: ‚Äî / ‚Äî</span>
            <button id="prevBtn">Prev</button>
            <button id="nextBtn">Next</button>
        </div>

        <div class="row">
            <div class="tools" style="gap:12px">
                <label class="radio" title="Nh·∫≠p nhi·ªÅu marker, c√°ch nhau d·∫•u ph·∫©y. VD: chuky1, chuky2, chuky3">
                    <span>üìç Marker(s)</span>
                    <input id="markerText" type="text" value="chuky1, chuky2, chuky3"
                           style="width:260px; margin-left:8px"/>
                </label>
                <label class="radio" title="R·ªông ·∫£nh k√Ω theo % b·ªÅ ngang trang">
                    <span>W%</span>
                    <input id="markerWpct" type="number" min="5" max="80" value="25"
                           style="width:70px; margin-left:8px"/>
                </label>
                <label class="radio" title="Che ch·ªØ marker b·∫±ng n·ªÅn tr·∫Øng">
                    <input id="coverMarkerToggle" type="checkbox" checked/> Che marker
                </label>
                <label class="radio" title="Kh√¥ng ph√¢n bi·ªát hoa/th∆∞·ªùng">
                    <input id="caseInsensitive" type="checkbox" checked/> i
                </label>
                <label class="radio" title="Kh·ªõp nguy√™n t·ª´ (b·ªè ch·ªçn ƒë·ªÉ 'ch·ª©a chu·ªói')">
                    <input id="wholeWord" type="checkbox" checked/> whole word
                </label>
                <label class="radio" title="D√πng OCR khi kh√¥ng th·∫•y text g·ªëc ho·∫∑c √©p d√πng OCR">
                    <input id="forceOCR" type="checkbox"/> D√πng OCR fallback
                </label>
                <label class="radio" title="T·ª∑ l·ªá render cho OCR (cao h∆°n = ch√≠nh x√°c h∆°n nh∆∞ng ch·∫≠m h∆°n)">
                    OCR scale
                    <input id="ocrScale" type="number" min="1" max="3" value="2" style="width:60px; margin-left:8px"/>
                </label>
                <label class="radio" title="Ng√¥n ng·ªØ OCR (eng/vie ho·∫∑c 'eng+vie')">
                    Lang
                    <input id="ocrLang" type="text" value="eng" class="mono" style="width:90px; margin-left:8px"/>
                </label>
                <label class="radio" title="B√π d·ªçc theo % chi·ªÅu cao ·∫£nh (√¢m = ƒë·∫©y l√™n)">
                    Y off %
                    <input id="yOffsetPct" type="number" min="-100" max="100" value="-18"
                           style="width:70px; margin-left:8px"/>
                </label>
                <label class="radio" title="ƒê·∫∑t t√¢m ·∫£nh tr√πng t√¢m marker; kh√¥ng d·ªãch ƒë·ªÉ tr√°nh l·ªách">
                    <input id="centerOnMarker" type="checkbox" checked/> Gi·ªØ t√¢m v√†o marker
                </label>
                <button id="autoSignBtn" class="primary">‚ö° Auto k√Ω to√†n t√†i li·ªáu</button>
                <button id="probeMarkersBtn">üîé Test t√¨m (trang hi·ªán t·∫°i)</button>
            </div>
        </div>

        <div class="row">
            <label class="radio">üîç Zoom
                <input id="zoomRange" type="range" min="50" max="200" value="100" style="width:180px; margin-left:8px"/>
            </label>
            <button id="fitBtn">Fit width</button>
            <span id="zoomLabel" class="hint">100%</span>
            <button id="exportBtn" class="primary" disabled>T·∫£i PDF ƒë√£ k√Ω</button>
        </div>

        <div class="hint">
            Quy tr√¨nh: Ch·ªçn PDF ‚ûú Ch·ªçn <b>nhi·ªÅu</b> ·∫£nh ch·ªØ k√Ω (n·∫øu c·∫ßn) ‚ûú Nh·∫≠p marker c√°ch nhau d·∫•u ph·∫©y
            (vd: <code>chuky1, chuky2, chuky3</code>) ‚ûú b·∫•m <b>‚ö° Auto k√Ω</b>. N·∫øu file l√† scan, b·∫≠t OCR.
        </div>
    </div>
</header>

<div class="wrap">
    <div class="canvasWrap">
        <div>
            <canvas id="pdfCanvas"></canvas>
        </div>
        <div class="right">
            <div class="card">
                <strong>M·ª•c ƒë√£ th√™m</strong>
                <div class="list" id="annoList"></div>
            </div>
            <div class="card">
                <strong>Th√¥ng tin</strong>
                <div class="hint" id="infoBox">Ch∆∞a c√≥ PDF.</div>
            </div>
        </div>
    </div>

    <div class="footer">
        <span class="hint">‚ö†Ô∏è Script ch·ªâ ch√®n overlay (rect/·∫£nh). Kh√¥ng ch·ªânh s·ª≠a text g·ªëc PDF.</span>
        <a class="link" href="#" id="sampleLink">D√πng th·ª≠ v·ªõi sample PDF</a>
    </div>
</div>

<script>
    if (window["pdfjsLib"]) {
        pdfjsLib.GlobalWorkerOptions.workerSrc =
            "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    }
    const {PDFDocument, rgb, StandardFonts} = PDFLib;

    const $ = (id) => document.getElementById(id);
    const pdfInput = $("pdfInput"),
        imgInput = $("imgInput"),
        canvas = $("pdfCanvas");
    const ctx = canvas.getContext("2d"),
        annoList = $("annoList"),
        infoBox = $("infoBox");
    const exportBtn = $("exportBtn"),
        sampleLink = $("sampleLink"),
        zoomRange = $("zoomRange");
    const fitBtn = $("fitBtn"),
        zoomLabel = $("zoomLabel"),
        pageInfo = $("pageInfo");
    const prevBtn = $("prevBtn"),
        nextBtn = $("nextBtn");
    const markerText = $("markerText"),
        markerWpct = $("markerWpct"),
        coverMarkerToggle = $("coverMarkerToggle");
    const autoSignBtn = $("autoSignBtn"),
        probeMarkersBtn = $("probeMarkersBtn");
    const caseInsensitive = $("caseInsensitive"),
        wholeWord = $("wholeWord");
    const forceOCR = $("forceOCR"),
        ocrScaleEl = $("ocrScale"),
        ocrLangEl = $("ocrLang");
    const centerOnMarker = $("centerOnMarker"),
        yOffsetPct = $("yOffsetPct");

    // State
    let pdfDoc = null, pdfBytesOriginal = null, annotations = [];
    let currentPage = 1, basePdfW = 0, basePdfH = 0, bufferScale = 1, currentZoom = 100;
    const MAX_CSS_WIDTH = 900, pageSizeCache = new Map();
    let signatureBank = []; // [{src,naturalWidth,naturalHeight,name}]

    const showInfo = (msg) => infoBox.innerHTML = msg;

    function addAnnoItem(anno, idx) {
        const div = document.createElement("div");
        div.className = "listItem";
        const label =
            anno.type === "image"
                ? `üñºÔ∏è p${anno.pageIndex} (x:${Math.round(anno.pdfX)}, y:${Math.round(anno.pdfY)}, ${Math.round(anno.pdfW)}x${Math.round(anno.pdfH)})`
                : `‚ñ≠ p${anno.pageIndex} (x:${Math.round(anno.pdfX)}, y:${Math.round(anno.pdfY)}, ${Math.round(anno.pdfW)}x${Math.round(anno.pdfH)})`;
        div.innerHTML = `<span class="badge">#${idx + 1}</span> <span>${label}</span>`;
        annoList.appendChild(div);
    }

    const rerenderAnnoList = () => {
        annoList.innerHTML = "";
        annotations.forEach(addAnnoItem);
    };

    async function getBasePageSize(pageIndex) {
        if (pageSizeCache.has(pageIndex)) return pageSizeCache.get(pageIndex);
        const page = await pdfDoc.getPage(pageIndex);
        const vp = page.getViewport({scale: 1});
        const sz = {w: vp.width, h: vp.height};
        pageSizeCache.set(pageIndex, sz);
        return sz;
    }

    async function renderPage() {
        const page = await pdfDoc.getPage(currentPage);
        const baseViewport = page.getViewport({scale: 1});
        basePdfW = baseViewport.width;
        basePdfH = baseViewport.height;

        const containerWidth = canvas.parentElement.getBoundingClientRect().width || MAX_CSS_WIDTH;
        const targetCssWidthFit = Math.min(containerWidth, MAX_CSS_WIDTH);
        const cssScale = (targetCssWidthFit * (currentZoom / 100)) / baseViewport.width;
        const dpr = window.devicePixelRatio || 1;
        bufferScale = cssScale * dpr;

        const viewport = page.getViewport({scale: bufferScale});
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = `${Math.round(baseViewport.width * cssScale)}px`;
        canvas.style.height = `${Math.round(baseViewport.height * cssScale)}px`;

        await page.render({canvasContext: ctx, viewport}).promise;

        // overlays
        for (const a of annotations.filter(x => x.pageIndex === currentPage && x.type === "rect")) {
            const xBuf = a.pdfX * bufferScale, yBuf = (basePdfH - a.pdfY) * bufferScale;
            ctx.save();
            ctx.fillStyle = "white";
            ctx.fillRect(xBuf, yBuf - a.pdfH * bufferScale, a.pdfW * bufferScale, a.pdfH * bufferScale);
            ctx.restore();
        }
        for (const a of annotations.filter(x => x.pageIndex === currentPage && x.type === "image")) {
            const xBuf = a.pdfX * bufferScale, yBuf = (basePdfH - a.pdfY) * bufferScale;
            await new Promise((res) => {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, xBuf, yBuf - a.pdfH * bufferScale, a.pdfW * bufferScale, a.pdfH * bufferScale);
                    res();
                };
                img.src = a.src;
            });
        }

        pageInfo.textContent = `Trang: ${currentPage} / ${pdfDoc.numPages}`;
    }

    function drawMarkerDebugBox(pdfX, pdfY, pdfW = 40, pdfH = 16) {
        const xBuf = pdfX * bufferScale, yBuf = (basePdfH - pdfY) * bufferScale;
        ctx.save();
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = Math.max(1, 1 * (window.devicePixelRatio || 1));
        ctx.strokeStyle = "rgba(239,68,68,0.95)";
        ctx.strokeRect(xBuf - (pdfW / 2) * bufferScale, yBuf - (pdfH / 2) * bufferScale, pdfW * bufferScale, pdfH * bufferScale);
        ctx.beginPath();
        ctx.moveTo(xBuf - 12, yBuf);
        ctx.lineTo(xBuf + 12, yBuf);
        ctx.moveTo(xBuf, yBuf - 12);
        ctx.lineTo(xBuf, yBuf + 12);
        ctx.stroke();
        ctx.restore();
    }

    async function loadPdfFromBytes(bytes) {
        const loadingTask = pdfjsLib.getDocument({data: bytes});
        pdfDoc = await loadingTask.promise;
        currentPage = 1;
        pageSizeCache.clear();
        currentZoom = 100;
        zoomRange.value = "100";
        zoomLabel.textContent = "100%";
        await renderPage();
        exportBtn.disabled = false;
        showInfo(`Trang: ${pdfDoc.numPages}. Ch·ªçn ·∫£nh ch·ªØ k√Ω r·ªìi b·∫•m ‚ö° Auto k√Ω.`);
    }

    function buildRegex(query, opts) {
        opts = opts || {};
        const caseInsensitive = opts.caseInsensitive !== false;
        const wholeWord = opts.wholeWord !== false;
        const esc = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const flags = (caseInsensitive ? "iu" : "u");
        if (wholeWord) {
            try {
                return new RegExp(`(?<![\\p{L}\\p{N}_])${esc}(?![\\p{L}\\p{N}_])`, flags);
            } catch {
                return new RegExp(`\\b${esc}\\b`, caseInsensitive ? "i" : "");
            }
        } else {
            return new RegExp(esc, caseInsensitive ? "i" : "");
        }
    }

    async function findMarkersOnDoc_TEXT(query = "HCNS", opts = {caseInsensitive: true, wholeWord: true}) {
        const re = buildRegex(query, opts);
        const hits = [];
        const total = pdfDoc.numPages;
        const Y_TOL = 2.5, GAP_RATIO = 0.35;

        for (let pageIndex = 1; pageIndex <= total; pageIndex++) {
            const page = await pdfDoc.getPage(pageIndex);
            const textContent = await page.getTextContent();
            const items = textContent.items || [];
            const spans = items.map(it => {
                const [a, b, c, d, e, f] = it.transform || [1, 0, 0, 1, 0, 0];
                const w = it.width || (it.str?.length || 1) * (Math.abs(a) || 8) || 40;
                const h = Math.abs(d) || 12;
                return {str: it.str || "", x: e, y: f, w, h};
            }).filter(s => s.str);

            spans.sort((p, q) => q.y - p.y || p.x - q.x);
            const lines = [];
            for (const s of spans) {
                const line = lines.find(L => Math.abs(L.y - s.y) <= Y_TOL);
                if (!line) lines.push({y: s.y, items: [s]}); else line.items.push(s);
            }

            for (const line of lines) {
                line.items.sort((p, q) => p.x - q.x);
                let text = "";
                const segs = [];
                let cursor = 0;
                for (let i = 0; i < line.items.length; i++) {
                    const it = line.items[i], prev = line.items[i - 1];
                    if (i > 0) {
                        const gap = it.x - (prev.x + prev.w);
                        const avgH = (it.h + prev.h) / 2;
                        if (gap > avgH * GAP_RATIO) {
                            text += " ";
                            cursor += 1;
                        }
                    }
                    const start = cursor;
                    text += it.str;
                    cursor += it.str.length;
                    segs.push({start, end: cursor, x: it.x, y: it.y, w: it.w, h: it.h});
                }
                if (!text) continue;

                const reG = new RegExp(re.source, re.flags.includes("g") ? re.flags : (re.flags + "g"));
                let mm;
                while ((mm = reG.exec(text)) !== null) {
                    const sIdx = mm.index, eIdx = sIdx + mm[0].length;
                    const take = segs.filter(seg => !(seg.end <= sIdx || seg.start >= eIdx));
                    if (!take.length) continue;
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    for (const g of take) {
                        minX = Math.min(minX, g.x);
                        maxX = Math.max(maxX, g.x + g.w);
                        minY = Math.min(minY, g.y - g.h);
                        maxY = Math.max(maxY, g.y);
                    }
                    const bboxW = Math.max(1, maxX - minX), bboxH = Math.max(1, maxY - minY);
                    const cx = minX + bboxW / 2, cy = minY + bboxH / 2;
                    hits.push({pageIndex, pdfX: cx, pdfY: cy, approxW: bboxW, approxH: bboxH});
                }
            }
        }
        return hits;
    }

    async function ocrRecognizePageToHits(pageIndex, query, opts, ocrScale = 2, lang = "eng") {
        const page = await pdfDoc.getPage(pageIndex);
        const vpBase = page.getViewport({scale: 1});
        const vp = page.getViewport({scale: ocrScale});
        const off = document.createElement("canvas");
        off.width = Math.floor(vp.width);
        off.height = Math.floor(vp.height);
        const offCtx = off.getContext("2d");
        await page.render({canvasContext: offCtx, viewport: vp}).promise;

        const res = await Tesseract.recognize(off, lang, {
            langPath: "https://tessdata.projectnaptha.com/4.0.0",
            logger: () => {
            }, tessedit_pageseg_mode: 6
        });

        const re = buildRegex(query, opts);
        const hits = [];
        const words = res?.data?.words || [];
        for (const w of words) {
            const text = (w.text || "").trim();
            if (!text) continue;
            if (!re.test(text)) continue;
            const {x0, y0, x1, y1} = w.bbox || {};
            if ([x0, y0, x1, y1].some(v => typeof v !== "number")) continue;
            const pdfH = vpBase.height;
            const cx_px = (x0 + x1) / 2, cy_px = (y0 + y1) / 2, bw_px = x1 - x0, bh_px = y1 - y0;
            const pdfX = cx_px / ocrScale, pdfY = pdfH - cy_px / ocrScale;
            const approxW = bw_px / ocrScale, approxH = bh_px / ocrScale;
            hits.push({pageIndex, pdfX, pdfY, approxW, approxH});
        }
        return hits;
    }

    async function findMarkersOnDoc_OCR(query = "HCNS", opts = {
        caseInsensitive: true,
        wholeWord: true
    }, ocrScale = 2, lang = "eng") {
        const total = pdfDoc.numPages, all = [];
        for (let pageIndex = 1; pageIndex <= total; pageIndex++) {
            const pageHits = await ocrRecognizePageToHits(pageIndex, query, opts, ocrScale, lang);
            all.push(...pageHits);
        }
        return all;
    }

    // ch·ªçn nhi·ªÅu ·∫£nh
    imgInput.addEventListener("change", async (e) => {
        if (!e.target.files?.length) return;
        signatureBank = [];
        for (const file of e.target.files) {
            if (!file.type.startsWith("image/")) continue;
            const src = URL.createObjectURL(file);
            const dims = await new Promise((res) => {
                const img = new Image();
                img.onload = () => res({w: img.naturalWidth, h: img.naturalHeight});
                img.src = src;
            });
            signatureBank.push({
                src,
                naturalWidth: dims.w,
                naturalHeight: dims.h,
                name: file.name.replace(/\.[^.]+$/, "")
            });
        }
        if (!signatureBank.length) return showInfo("Kh√¥ng c√≥ ·∫£nh h·ª£p l·ªá.");
        showInfo(signatureBank.length > 1 ? `ƒê√£ ch·ªçn ${signatureBank.length} ·∫£nh ch·ªØ k√Ω.` : `ƒê√£ ch·ªçn 1 ·∫£nh ch·ªØ k√Ω.`);
    });

    async function autoSignAcrossDoc() {
        if (!pdfDoc) return showInfo("Ch∆∞a c√≥ PDF.");
        if (!signatureBank.length) return showInfo("H√£y ch·ªçn √≠t nh·∫•t m·ªôt ·∫£nh ch·ªØ k√Ω (n√∫t üñºÔ∏è).");

        const markers = (markerText.value || "").split(",").map(s => s.trim()).filter(Boolean);
        if (!markers.length) return showInfo("Nh·∫≠p √≠t nh·∫•t m·ªôt marker, c√°ch nhau b·∫±ng d·∫•u ph·∫©y.");

        const opts = {caseInsensitive: caseInsensitive.checked, wholeWord: wholeWord.checked};
        const allHits = [];

        for (let i = 0; i < markers.length; i++) {
            const query = markers[i];
            let hits = await findMarkersOnDoc_TEXT(query, opts);
            if (forceOCR.checked || !hits.length) {
                const ocrScale = parseFloat(ocrScaleEl.value || 2);
                const lang = (ocrLangEl.value || "eng").trim();
                const ocrHits = await findMarkersOnDoc_OCR(query, opts, Math.max(1, Math.min(3, ocrScale)), lang);
                const key = (h) => `${h.pageIndex}:${Math.round(h.pdfX)}:${Math.round(h.pdfY)}`;
                const seen = new Set(hits.map(key));
                for (const h of ocrHits) if (!seen.has(key(h))) hits.push(h);
            }
            for (const h of hits) {
                h._markerIndex = i;
                h._markerText = query;
                allHits.push(h);
            }
        }

        if (!allHits.length) return showInfo(`Kh√¥ng th·∫•y marker n√†o (${markers.join(", ")}).`);

        const newAnn = [];
        let skipped = 0;

        for (const h of allHits) {
            const sig = signatureBank[h._markerIndex];      // ·∫£nh tr√πng th·ª© t·ª± marker
            if (!sig) {
                skipped++;
                continue;
            }              // thi·∫øu ·∫£nh ‚Üí b·ªè qua

            const {w: pageW, h: pageH} = await getBasePageSize(h.pageIndex);
            const wpct = Math.max(5, Math.min(80, parseFloat(markerWpct.value || 25)));
            const targetPdfW = pageW * (wpct / 100);
            const scale = targetPdfW / sig.naturalWidth;
            const finalW = targetPdfW, finalH = sig.naturalHeight * scale;

            // offset d·ªçc theo % chi·ªÅu cao ·∫£nh (√¢m = ƒë·∫©y l√™n)
            const yOff = (parseFloat(yOffsetPct.value || 0) / 100) * finalH;

            // che marker (center-based)
            if (coverMarkerToggle.checked) {
                const pad = 4;
                const rectW = Math.max(h.approxW + pad * 2, finalW * 0.4);
                const rectH = Math.max(h.approxH + pad * 2, finalH * 0.4);
                let coverX = h.pdfX - rectW / 2, coverY = (h.pdfY + yOff) - rectH / 2;
                if (!centerOnMarker.checked) {
                    coverX = Math.max(0, Math.min(coverX, pageW - rectW));
                    coverY = Math.max(0, Math.min(coverY, pageH - rectH));
                }
                newAnn.push({
                    type: "rect",
                    pageIndex: h.pageIndex,
                    pdfX: coverX,
                    pdfY: coverY,
                    pdfW: rectW,
                    pdfH: rectH
                });
            }

            // ƒë·∫∑t ·∫£nh: t√¢m ·∫£nh = t√¢m marker (+ b√π Y)
            let pdfXPlace = h.pdfX - finalW / 2;
            let pdfYPlace = (h.pdfY + yOff) - finalH / 2;
            if (!centerOnMarker.checked) {
                pdfXPlace = Math.max(0, Math.min(pdfXPlace, pageW - finalW));
                pdfYPlace = Math.max(0, Math.min(pdfYPlace, pageH - finalH));
            }
            newAnn.push({
                type: "image",
                pageIndex: h.pageIndex,
                pdfX: pdfXPlace,
                pdfY: pdfYPlace,
                pdfW: finalW,
                pdfH: finalH,
                src: sig.src
            });
        }

        annotations.push(...newAnn);
        await renderPage();
        rerenderAnnoList();

        const placed = newAnn.filter(a => a.type === "image").length;
        if (skipped > 0) showInfo(`ƒê√£ k√Ω ${placed} v·ªã tr√≠. B·ªè qua ${skipped} hit v√¨ thi·∫øu ·∫£nh t∆∞∆°ng ·ª©ng marker.`);
        else showInfo(`ƒê√£ k√Ω ${placed} v·ªã tr√≠ (t·∫•t c·∫£ marker ƒë·ªÅu c√≥ ·∫£nh).`);
    }

    // events
    pdfInput.addEventListener("change", async (e) => {
        if (!e.target.files?.length) return;
        const file = e.target.files[0];
        const ab = await file.arrayBuffer();
        const bytes = new Uint8Array(ab);
        pdfBytesOriginal = bytes.slice();
        annotations = [];
        rerenderAnnoList();
        await loadPdfFromBytes(bytes.slice());
    });

    autoSignBtn.addEventListener("click", autoSignAcrossDoc);

    probeMarkersBtn.addEventListener("click", async () => {
        if (!pdfDoc) return showInfo("Ch∆∞a c√≥ PDF.");
        const markers = (markerText.value || "").split(",").map(s => s.trim()).filter(Boolean);
        if (!markers.length) return showInfo("Nh·∫≠p √≠t nh·∫•t m·ªôt marker, c√°ch nhau d·∫•u ph·∫©y.");
        const opts = {caseInsensitive: caseInsensitive.checked, wholeWord: wholeWord.checked};
        let hits = [];
        for (const query of markers) {
            let h1 = await findMarkersOnDoc_TEXT(query, opts);
            if (forceOCR.checked || !h1.length) {
                const ocrScale = parseFloat(ocrScaleEl.value || 2);
                const lang = (ocrLangEl.value || "eng").trim();
                const ocrHits = await findMarkersOnDoc_OCR(query, opts, Math.max(1, Math.min(3, ocrScale)), lang);
                const key = (h) => `${h.pageIndex}:${Math.round(h.pdfX)}:${Math.round(h.pdfY)}`;
                const seen = new Set(h1.map(key));
                for (const hh of ocrHits) if (!seen.has(key(hh))) h1.push(hh);
            }
            hits.push(...h1);
        }
        await renderPage();
        const pageHits = hits.filter((h) => h.pageIndex === currentPage);
        if (!pageHits.length) return showInfo(`Trang ${currentPage}: kh√¥ng th·∫•y marker n√†o trong (${markers.join(", ")}).`);
        for (const h of pageHits) drawMarkerDebugBox(h.pdfX, h.pdfY, h.approxW, h.approxH);
        showInfo(`Trang ${currentPage}: ${pageHits.length} hit (${markers.join(", ")}) ‚Äî ƒë√£ highlight.`);
    });

    prevBtn.addEventListener("click", async () => {
        if (!pdfDoc) return;
        currentPage = Math.max(1, currentPage - 1);
        await renderPage();
    });
    nextBtn.addEventListener("click", async () => {
        if (!pdfDoc) return;
        currentPage = Math.min(pdfDoc.numPages, currentPage + 1);
        await renderPage();
    });

    zoomRange.addEventListener("input", async (e) => {
        currentZoom = parseInt(e.target.value, 10);
        zoomLabel.textContent = currentZoom + "%";
        if (pdfDoc) await renderPage();
    });
    fitBtn.addEventListener("click", async () => {
        currentZoom = 100;
        zoomRange.value = "100";
        zoomLabel.textContent = "100%";
        if (pdfDoc) await renderPage();
    });
    window.addEventListener("resize", async () => {
        if (pdfDoc) await renderPage();
    });

    // ===== Export: √°nh x·∫° top-left (pdf.js/CropBox) -> bottom-left (pdf-lib/MediaBox) chu·∫©n t·ª´ng trang
    exportBtn.addEventListener("click", async () => {
        if (!pdfBytesOriginal) return;

        const pdfDocOut = await PDFLib.PDFDocument.load(pdfBytesOriginal);
        await pdfDocOut.embedFont(PDFLib.StandardFonts.Helvetica);

        // L·∫•y k√≠ch th∆∞·ªõc th·∫≠t pdf-lib ƒëang v·∫Ω, v√† chuy·ªÉn h·ªá tr·ª•c ƒë√∫ng cho t·ª´ng trang
        // L∆ØU √ù: a.pdfX, a.pdfY ƒëang l√† bottom-left (ƒë√°y tr√°i) trong h·ªá pdf.js
        function mapAnnoToPdfLib(page, pageIndex, a) {
            const media = page.getMediaBox();                         // {x,y,width,height}
            const crop = page.getCropBox ? page.getCropBox() : media;

            // K√≠ch th∆∞·ªõc v·∫Ω theo CropBox (ƒë·ªÉ kh·ªõp pdf.js)
            const libW = crop.width;
            const libH = crop.height;

            // K√≠ch th∆∞·ªõc pdf.js d√πng khi ƒëo (cache khi render)
            const jsSize = pageSizeCache.get(pageIndex) || {w: libW, h: libH};
            const sx = libW / jsSize.w;
            const sy = libH / jsSize.h;

            // Scale k√≠ch th∆∞·ªõc overlay
            const w = a.pdfW * sx;
            const h = a.pdfH * sy;

            // KH√îNG l·∫≠t tr·ª•c Y n·ªØa: a.pdfY ƒë√£ l√† bottom-left
            const x_inCropBL = a.pdfX * sx;
            const y_inCropBL = a.pdfY * sy;

            // B√π offset CropBox so v·ªõi MediaBox (pdf-lib v·∫Ω theo MediaBox)
            const dx = (crop.x ?? 0) - (media.x ?? 0);
            const dy = (crop.y ?? 0) - (media.y ?? 0);

            return {x: dx + x_inCropBL, y: dy + y_inCropBL, w, h};
        }


        for (const a of annotations) {
            const page = pdfDocOut.getPage((a.pageIndex || 1) - 1);
            const m = mapAnnoToPdfLib(page, a.pageIndex, a);

            if (a.type === "rect") {
                page.drawRectangle({x: m.x, y: m.y, width: m.w, height: m.h, color: PDFLib.rgb(1, 1, 1)});
            } else if (a.type === "image") {
                const bytes = await fetch(a.src).then(r => r.arrayBuffer());
                let imgEmbed;
                try {
                    imgEmbed = await pdfDocOut.embedPng(bytes);
                } catch {
                    imgEmbed = await pdfDocOut.embedJpg(bytes);
                }
                page.drawImage(imgEmbed, {x: m.x, y: m.y, width: m.w, height: m.h});
            }
        }

        const outBytes = await pdfDocOut.save();
        const blob = new Blob([outBytes], {type: "application/pdf"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "signed.pdf";
        a.click();
        URL.revokeObjectURL(url);
    });

    // Sample PDF
    sampleLink.addEventListener("click", async (e) => {
        e.preventDefault();
        const ab = await fetch("https://unec.edu.az/application/uploads/2014/12/pdf-sample.pdf").then((r) => r.arrayBuffer());
        const bytes = new Uint8Array(ab);
        pdfBytesOriginal = bytes.slice();
        annotations = [];
        rerenderAnnoList();
        await loadPdfFromBytes(bytes.slice());
    });
</script>
</body>

</html>