<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF Auto Sign (HCNS) + OCR fallback</title>

    <!-- pdf.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- pdf-lib -->
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <!-- Tesseract.js (OCR) -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.1/dist/tesseract.min.js"></script>

    <style>
      :root {
        --bg: #0f172a;
        --muted: #1e293b;
        --ink: #e2e8f0;
        --accent: #22d3ee;
        --line: #334155;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font: 14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI,
          Roboto, Arial;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 10;
        background: linear-gradient(
          180deg,
          rgba(15, 23, 42, 0.98),
          rgba(15, 23, 42, 0.92)
        );
        backdrop-filter: blur(8px);
        border-bottom: 1px solid var(--line);
      }
      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 16px;
      }
      h1 {
        font-size: 18px;
        margin: 0 0 6px;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .card {
        background: var(--muted);
        border: 1px solid var(--line);
        border-radius: 14px;
        padding: 12px;
      }
      label.btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border: 1px dashed var(--line);
        border-radius: 10px;
        cursor: pointer;
      }
      input[type="file"] {
        display: none;
      }
      button {
        appearance: none;
        border: 1px solid var(--line);
        background: #0b1220;
        color: var(--ink);
        padding: 8px 12px;
        border-radius: 10px;
        cursor: pointer;
      }
      button.primary {
        border-color: transparent;
        background: linear-gradient(90deg, #06b6d4, #22d3ee);
        color: #0b1220;
        font-weight: 700;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .tools {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .tools input[type="text"],
      .tools input[type="number"],
      .tools select {
        background: #0b1220;
        color: var(--ink);
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
      }
      .canvasWrap {
        display: grid;
        grid-template-columns: 1fr 320px;
        gap: 12px;
        margin: 16px 0;
      }
      .right {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .hint {
        opacity: 0.8;
        font-size: 12px;
      }
      canvas {
        width: 100%;
        height: auto;
        max-width: 900px;
        background: white;
        border-radius: 8px;
        border: 1px solid var(--line);
      }
      .list {
        max-height: 360px;
        overflow: auto;
        border: 1px solid var(--line);
        border-radius: 10px;
      }
      .listItem {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        padding: 8px;
        border-bottom: 1px dashed var(--line);
      }
      .badge {
        font-size: 12px;
        padding: 2px 6px;
        border-radius: 6px;
        background: #0b1220;
        border: 1px solid var(--line);
      }
      .radio {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        padding: 6px 10px;
        border: 1px solid var(--line);
        border-radius: 10px;
      }
      .radio input {
        margin: 0;
      }
      .footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 12px 0;
      }
      a.link {
        color: var(--accent);
        text-decoration: none;
      }
      .pill {
        padding: 4px 8px;
        border: 1px solid var(--line);
        border-radius: 999px;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="wrap">
        <h1>PDF Auto Sign ‚Äî K√Ω v√†o m·ªçi ‚ÄúHCNS‚Äù (c√≥ OCR)</h1>

        <div class="row">
          <label class="btn"
            ><input id="pdfInput" type="file" accept="application/pdf" /><span
              >üìÑ Ch·ªçn PDF‚Ä¶</span
            ></label
          >
          <label class="btn" title="PNG/JPG, n√™n PNG n·ªÅn trong su·ªët"
            ><input id="imgInput" type="file" accept="image/*" /><span
              >üñºÔ∏è Ch·ªçn ·∫£nh ch·ªØ k√Ω</span
            ></label
          >
          <span id="pageInfo" class="pill">Trang: ‚Äî / ‚Äî</span>
          <button id="prevBtn">Prev</button>
          <button id="nextBtn">Next</button>
        </div>

        <div class="row">
          <div class="tools" style="gap: 12px">
            <label class="radio" title="Chu·ªói c·∫ßn t√¨m (v√≠ d·ª• HCNS)"
              ><span>üìç Marker</span>
              <input
                id="markerText"
                type="text"
                value="HCNS"
                style="width: 140px; margin-left: 8px"
              />
            </label>
            <label class="radio" title="R·ªông ·∫£nh k√Ω theo % b·ªÅ ngang trang">
              <span>W%</span>
              <input
                id="markerWpct"
                type="number"
                min="5"
                max="80"
                value="25"
                style="width: 70px; margin-left: 8px"
              />
            </label>
            <label class="radio" title="Che ch·ªØ marker b·∫±ng n·ªÅn tr·∫Øng">
              <input id="coverMarkerToggle" type="checkbox" checked /> Che
              marker
            </label>
            <label class="radio" title="Kh√¥ng ph√¢n bi·ªát hoa/th∆∞·ªùng">
              <input id="caseInsensitive" type="checkbox" checked /> i
            </label>
            <label
              class="radio"
              title="Kh·ªõp nguy√™n t·ª´ (b·ªè ch·ªçn ƒë·ªÉ 'ch·ª©a chu·ªói')"
            >
              <input id="wholeWord" type="checkbox" checked /> whole word
            </label>
            <label
              class="radio"
              title="D√πng OCR khi kh√¥ng th·∫•y text g·ªëc ho·∫∑c √©p d√πng OCR"
            >
              <input id="forceOCR" type="checkbox" /> D√πng OCR fallback
            </label>
            <label
              class="radio"
              title="T·ª∑ l·ªá render cho OCR (cao h∆°n = ch√≠nh x√°c h∆°n nh∆∞ng ch·∫≠m h∆°n)"
            >
              OCR scale
              <input
                id="ocrScale"
                type="number"
                min="1"
                max="3"
                value="2"
                style="width: 60px; margin-left: 8px"
              />
            </label>
            <label class="radio" title="Ng√¥n ng·ªØ OCR (eng/vie ho·∫∑c 'eng+vie')">
              Lang
              <input
                id="ocrLang"
                type="text"
                value="eng"
                class="mono"
                style="width: 90px; margin-left: 8px"
              />
            </label>
            <button id="autoSignBtn" class="primary">
              ‚ö° Auto k√Ω to√†n t√†i li·ªáu
            </button>
            <button id="probeMarkersBtn">üîé Test t√¨m (trang hi·ªán t·∫°i)</button>
          </div>
        </div>

        <div class="row">
          <label class="radio"
            >üîç Zoom
            <input
              id="zoomRange"
              type="range"
              min="50"
              max="200"
              value="100"
              style="width: 180px; margin-left: 8px"
            />
          </label>
          <button id="fitBtn">Fit width</button>
          <span id="zoomLabel" class="hint">100%</span>
          <button id="exportBtn" class="primary" disabled>T·∫£i PDF ƒë√£ k√Ω</button>
        </div>

        <div class="hint">
          Quy tr√¨nh: Ch·ªçn PDF ‚ûú Ch·ªçn ·∫£nh ch·ªØ k√Ω ‚ûú b·∫•m <b>‚ö° Auto k√Ω</b>. N·∫øu
          file l√† scan, b·∫≠t <b>D√πng OCR fallback</b> (ng√¥n ng·ªØ OCR:
          <code>eng</code>, ho·∫∑c <code>vie</code>/<code>eng+vie</code> tu·ª≥ t√†i
          li·ªáu).
        </div>
      </div>
    </header>

    <div class="wrap">
      <div class="canvasWrap">
        <div><canvas id="pdfCanvas"></canvas></div>
        <div class="right">
          <div class="card">
            <strong>M·ª•c ƒë√£ th√™m</strong>
            <div class="list" id="annoList"></div>
          </div>
          <div class="card">
            <strong>Th√¥ng tin</strong>
            <div class="hint" id="infoBox">Ch∆∞a c√≥ PDF.</div>
          </div>
        </div>
      </div>

      <div class="footer">
        <span class="hint"
          >‚ö†Ô∏è Script ch·ªâ ch√®n overlay (rect/·∫£nh). Kh√¥ng ch·ªânh s·ª≠a text g·ªëc
          PDF.</span
        >
        <a class="link" href="#" id="sampleLink">D√πng th·ª≠ v·ªõi sample PDF</a>
      </div>
    </div>

    <script>
      // pdf.js worker
      if (window["pdfjsLib"]) {
        pdfjsLib.GlobalWorkerOptions.workerSrc =
          "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
      }
      const { PDFDocument, rgb, StandardFonts } = PDFLib;

      // DOM
      const $ = (id) => document.getElementById(id);
      const pdfInput = $("pdfInput"),
        imgInput = $("imgInput"),
        canvas = $("pdfCanvas");
      const ctx = canvas.getContext("2d"),
        annoList = $("annoList"),
        infoBox = $("infoBox");
      const exportBtn = $("exportBtn"),
        sampleLink = $("sampleLink"),
        zoomRange = $("zoomRange");
      const fitBtn = $("fitBtn"),
        zoomLabel = $("zoomLabel"),
        pageInfo = $("pageInfo");
      const prevBtn = $("prevBtn"),
        nextBtn = $("nextBtn");
      const markerText = $("markerText"),
        markerWpct = $("markerWpct"),
        coverMarkerToggle = $("coverMarkerToggle");
      const autoSignBtn = $("autoSignBtn"),
        probeMarkersBtn = $("probeMarkersBtn");
      const caseInsensitive = $("caseInsensitive"),
        wholeWord = $("wholeWord");
      const forceOCR = $("forceOCR"),
        ocrScaleEl = $("ocrScale"),
        ocrLangEl = $("ocrLang");

      // State
      let pdfDoc = null,
        pdfBytesOriginal = null,
        annotations = [];
      let signatureDataUrl = null;
      let currentPage = 1,
        basePdfW = 0,
        basePdfH = 0,
        bufferScale = 1,
        currentZoom = 100;
      const MAX_CSS_WIDTH = 900,
        pageSizeCache = new Map();

      function showInfo(msg) {
        infoBox.innerHTML = msg;
      }
      function addAnnoItem(anno, idx) {
        const div = document.createElement("div");
        div.className = "listItem";
        let label = "";
        if (anno.type === "image") {
          label = `üñºÔ∏è p${anno.pageIndex} (x:${Math.round(
            anno.pdfX
          )}, y:${Math.round(anno.pdfY)}, ${Math.round(anno.pdfW)}x${Math.round(
            anno.pdfH
          )})`;
        } else if (anno.type === "rect") {
          label = `‚ñ≠ p${anno.pageIndex} (x:${Math.round(
            anno.pdfX
          )}, y:${Math.round(anno.pdfY)}, ${Math.round(anno.pdfW)}x${Math.round(
            anno.pdfH
          )})`;
        }
        div.innerHTML = `<span class="badge">#${
          idx + 1
        }</span> <span>${label}</span>`;
        annoList.appendChild(div);
      }
      function rerenderAnnoList() {
        annoList.innerHTML = "";
        annotations.forEach(addAnnoItem);
      }

      async function getBasePageSize(pageIndex) {
        if (pageSizeCache.has(pageIndex)) return pageSizeCache.get(pageIndex);
        const page = await pdfDoc.getPage(pageIndex);
        const vp = page.getViewport({ scale: 1 });
        const sz = { w: vp.width, h: vp.height };
        pageSizeCache.set(pageIndex, sz);
        return sz;
      }

      async function renderPage() {
        const page = await pdfDoc.getPage(currentPage);
        const baseViewport = page.getViewport({ scale: 1 });
        basePdfW = baseViewport.width;
        basePdfH = baseViewport.height;

        const containerWidth =
          canvas.parentElement.getBoundingClientRect().width || MAX_CSS_WIDTH;
        const targetCssWidthFit = Math.min(containerWidth, MAX_CSS_WIDTH);
        const cssScale =
          (targetCssWidthFit * (currentZoom / 100)) / baseViewport.width;
        const dpr = window.devicePixelRatio || 1;
        bufferScale = cssScale * dpr;

        const viewport = page.getViewport({ scale: bufferScale });
        canvas.width = Math.floor(viewport.width);
        canvas.height = Math.floor(viewport.height);
        canvas.style.width = `${Math.round(baseViewport.width * cssScale)}px`;
        canvas.style.height = `${Math.round(baseViewport.height * cssScale)}px`;

        await page.render({ canvasContext: ctx, viewport }).promise;

        // draw overlays for current page
        for (const a of annotations.filter(
          (x) => x.pageIndex === currentPage && x.type === "rect"
        )) {
          const xBuf = a.pdfX * bufferScale,
            yBuf = (basePdfH - a.pdfY) * bufferScale;
          ctx.save();
          ctx.fillStyle = "white";
          ctx.fillRect(
            xBuf,
            yBuf - a.pdfH * bufferScale,
            a.pdfW * bufferScale,
            a.pdfH * bufferScale
          );
          ctx.restore();
        }
        for (const a of annotations.filter(
          (x) => x.pageIndex === currentPage && x.type === "image"
        )) {
          const xBuf = a.pdfX * bufferScale,
            yBuf = (basePdfH - a.pdfY) * bufferScale;
          await new Promise((res) => {
            const img = new Image();
            img.onload = () => {
              ctx.drawImage(
                img,
                xBuf,
                yBuf - a.pdfH * bufferScale,
                a.pdfW * bufferScale,
                a.pdfH * bufferScale
              );
              res();
            };
            img.src = a.src;
          });
        }

        pageInfo.textContent = `Trang: ${currentPage} / ${pdfDoc.numPages}`;
      }

      function drawMarkerDebugBox(pdfX, pdfY, pdfW = 40, pdfH = 16) {
        const xBuf = pdfX * bufferScale,
          yBuf = (basePdfH - pdfY) * bufferScale;
        ctx.save();
        ctx.setLineDash([6, 4]);
        ctx.lineWidth = Math.max(1, 1 * (window.devicePixelRatio || 1));
        ctx.strokeStyle = "rgba(239,68,68,0.95)";
        ctx.strokeRect(
          xBuf - (pdfW / 2) * bufferScale,
          yBuf - (pdfH / 2) * bufferScale,
          pdfW * bufferScale,
          pdfH * bufferScale
        );
        ctx.beginPath();
        ctx.moveTo(xBuf - 12, yBuf);
        ctx.lineTo(xBuf + 12, yBuf);
        ctx.moveTo(xBuf, yBuf - 12);
        ctx.lineTo(xBuf, yBuf + 12);
        ctx.stroke();
        ctx.restore();
      }

      async function loadPdfFromBytes(bytes) {
        const loadingTask = pdfjsLib.getDocument({ data: bytes });
        pdfDoc = await loadingTask.promise;
        currentPage = 1;
        pageSizeCache.clear();
        currentZoom = 100;
        zoomRange.value = "100";
        zoomLabel.textContent = "100%";
        await renderPage();
        exportBtn.disabled = false;
        showInfo(
          `Trang: ${pdfDoc.numPages}. Ch·ªçn ·∫£nh ch·ªØ k√Ω r·ªìi b·∫•m ‚ö° Auto k√Ω.`
        );
      }

      function buildRegex(query, opts) {
        opts = opts || {};
        const caseInsensitive = opts.caseInsensitive !== false; // m·∫∑c ƒë·ªãnh true
        const wholeWord = opts.wholeWord !== false; // m·∫∑c ƒë·ªãnh true
        const esc = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const pattern = wholeWord ? `\\b${esc}\\b` : esc;
        return new RegExp(pattern, caseInsensitive ? "i" : "");
      }

      async function findMarkersOnDoc_TEXT(
        query = "HCNS",
        opts = { caseInsensitive: true, wholeWord: true }
      ) {
        const re = buildRegex(query, opts);
        const hits = [];
        const total = pdfDoc.numPages;
        for (let pageIndex = 1; pageIndex <= total; pageIndex++) {
          const page = await pdfDoc.getPage(pageIndex);
          const textContent = await page.getTextContent();
          const items = textContent.items || [];
          const map = items.map((it) => {
            const [a, b, c, d, e, f] = it.transform || [1, 0, 0, 1, 0, 0];
            const w =
              it.width || (it.str?.length || 1) * (Math.abs(a) || 8) || 40;
            const h = Math.abs(d) || 12;
            return { str: it.str || "", pdfX: e, pdfY: f, w, h };
          });
          for (const m of map) {
            if (m.str && re.test(m.str)) {
              hits.push({
                pageIndex,
                pdfX: m.pdfX,
                pdfY: m.pdfY,
                approxW: m.w,
                approxH: m.h,
              });
            }
          }
          // try sliding join if needed (optional)
        }
        return hits;
      }

      async function ocrRecognizePageToHits(
        pageIndex,
        query,
        opts,
        ocrScale = 2,
        lang = "eng"
      ) {
        // Render page to offscreen canvas at ocrScale
        const page = await pdfDoc.getPage(pageIndex);
        const vpBase = page.getViewport({ scale: 1 });
        const vp = page.getViewport({ scale: ocrScale });
        const off = document.createElement("canvas");
        off.width = Math.floor(vp.width);
        off.height = Math.floor(vp.height);
        const offCtx = off.getContext("2d");
        await page.render({ canvasContext: offCtx, viewport: vp }).promise;

        // OCR via Tesseract
        const langPath = "https://tessdata.projectnaptha.com/4.0.0"; // public tessdata
        const res = await Tesseract.recognize(off, lang, {
          langPath,
          logger: (m) => {
            /* console.log(m) */
          },
          tessedit_pageseg_mode: 6, // assume a block of text
        });

        const re = buildRegex(query, opts);
        const hits = [];
        const words = res?.data?.words || [];
        for (const w of words) {
          const text = (w.text || "").trim();
          if (!text) continue;
          if (!re.test(text)) continue;
          const { x0, y0, x1, y1 } = w.bbox || {};
          if ([x0, y0, x1, y1].some((v) => typeof v !== "number")) continue;
          const pdfW = vpBase.width,
            pdfH = vpBase.height;
          // Convert OCR px (rendered at ocrScale) -> PDF points
          const cx_px = (x0 + x1) / 2,
            cy_px = (y0 + y1) / 2;
          const bw_px = x1 - x0,
            bh_px = y1 - y0;
          const pdfX = cx_px / ocrScale;
          const pdfY = pdfH - cy_px / ocrScale; // invert Y
          const approxW = bw_px / ocrScale,
            approxH = bh_px / ocrScale;
          hits.push({ pageIndex, pdfX, pdfY, approxW, approxH });
        }
        return hits;
      }

      async function findMarkersOnDoc_OCR(
        query = "HCNS",
        opts = { caseInsensitive: true, wholeWord: true },
        ocrScale = 2,
        lang = "eng"
      ) {
        const total = pdfDoc.numPages;
        const all = [];
        for (let pageIndex = 1; pageIndex <= total; pageIndex++) {
          const pageHits = await ocrRecognizePageToHits(
            pageIndex,
            query,
            opts,
            ocrScale,
            lang
          );
          all.push(...pageHits);
        }
        return all;
      }

      async function autoSignAcrossDoc() {
        if (!pdfDoc) return showInfo("Ch∆∞a c√≥ PDF.");
        if (!signatureDataUrl)
          return showInfo("H√£y ch·ªçn ·∫£nh ch·ªØ k√Ω tr∆∞·ªõc (n√∫t üñºÔ∏è).");

        const query = (markerText.value || "HCNS").trim();
        if (!query) return showInfo("Nh·∫≠p chu·ªói c·∫ßn t√¨m (v√≠ d·ª• HCNS).");

        const opts = {
          caseInsensitive: caseInsensitive.checked,
          wholeWord: wholeWord.checked,
        };
        let hits = [];
        if (!forceOCR.checked) {
          hits = await findMarkersOnDoc_TEXT(query, opts);
        }
        if (forceOCR.checked || !hits.length) {
          showInfo("ƒêang ch·∫°y OCR fallback‚Ä¶");
          const ocrScale = parseFloat(ocrScaleEl.value || 2);
          const lang = (ocrLangEl.value || "eng").trim();
          const ocrHits = await findMarkersOnDoc_OCR(
            query,
            opts,
            Math.max(1, Math.min(3, ocrScale)),
            lang
          );
          // n·∫øu tr∆∞·ªõc ƒë√≥ c√≥ hits t·ª´ text, gh√©p th√™m (tr√°nh tr√πng b·∫±ng kh√≥a g·∫ßn t√¢m)
          const key = (h) =>
            `${h.pageIndex}:${Math.round(h.pdfX)}:${Math.round(h.pdfY)}`;
          const seen = new Set(hits.map(key));
          for (const h of ocrHits) {
            if (!seen.has(key(h))) {
              hits.push(h);
              seen.add(key(h));
            }
          }
        }

        if (!hits.length) {
          showInfo(`Kh√¥ng th·∫•y "${query}" trong t√†i li·ªáu (k·ªÉ c·∫£ OCR).`);
          return;
        }

        // Load signature image once
        const img = new Image();
        await new Promise((res) => {
          img.onload = res;
          img.src = signatureDataUrl;
        });

        const newAnn = [];
        for (const h of hits) {
          const { w: pageW, h: pageH } = await getBasePageSize(h.pageIndex);
          const wpct = Math.max(
            5,
            Math.min(80, parseFloat(markerWpct.value || 25))
          );
          const targetPdfW = pageW * (wpct / 100);
          const scale = targetPdfW / img.naturalWidth;
          const finalW = targetPdfW,
            finalH = img.naturalHeight * scale;

          if (coverMarkerToggle.checked) {
            const pad = 4;
            const rectW = Math.max(h.approxW + pad * 2, finalW * 0.4);
            const rectH = Math.max(h.approxH + pad * 2, finalH * 0.4);
            let coverX = h.pdfX - rectW / 2,
              coverY = h.pdfY - rectH / 2;
            coverX = Math.max(0, Math.min(coverX, pageW - rectW));
            coverY = Math.max(0, Math.min(coverY, pageH - rectH));
            newAnn.push({
              type: "rect",
              pageIndex: h.pageIndex,
              pdfX: coverX,
              pdfY: coverY,
              pdfW: rectW,
              pdfH: rectH,
            });
          }

          let pdfXPlace = h.pdfX - finalW / 2;
          let pdfYPlace = h.pdfY - finalH / 2;
          pdfXPlace = Math.max(0, Math.min(pdfXPlace, pageW - finalW));
          pdfYPlace = Math.max(0, Math.min(pdfYPlace, pageH - finalH));

          newAnn.push({
            type: "image",
            pageIndex: h.pageIndex,
            pdfX: pdfXPlace,
            pdfY: pdfYPlace,
            pdfW: finalW,
            pdfH: finalH,
            src: signatureDataUrl,
          });
        }

        annotations.push(...newAnn);
        await renderPage();
        rerenderAnnoList();
        showInfo(
          `ƒê√£ k√Ω ${hits.length} v·ªã tr√≠ cho "${query}" tr√™n ${pdfDoc.numPages} trang.`
        );
      }

      // events
      pdfInput.addEventListener("change", async (e) => {
        if (!e.target.files?.length) return;
        const file = e.target.files[0];
        const ab = await file.arrayBuffer();
        const bytes = new Uint8Array(ab);
        pdfBytesOriginal = bytes.slice();
        annotations = [];
        rerenderAnnoList();
        await loadPdfFromBytes(bytes.slice());
      });

      imgInput.addEventListener("change", async (e) => {
        if (!e.target.files?.length) return;
        const file = e.target.files[0];
        if (!file.type.startsWith("image/"))
          return showInfo("·∫¢nh ch·ªØ k√Ω ph·∫£i l√† PNG/JPG.");
        signatureDataUrl = URL.createObjectURL(file);
        showInfo(
          "ƒê√£ ch·ªçn ·∫£nh ch·ªØ k√Ω. B·∫•m ‚ö° Auto k√Ω ƒë·ªÉ ch√®n v√†o m·ªçi ‚Äú" +
            (markerText.value || "HCNS") +
            "‚Äù."
        );
      });

      autoSignBtn.addEventListener("click", autoSignAcrossDoc);

      probeMarkersBtn.addEventListener("click", async () => {
        if (!pdfDoc) return showInfo("Ch∆∞a c√≥ PDF.");
        const query = (markerText.value || "HCNS").trim() || "HCNS";
        const opts = {
          caseInsensitive: caseInsensitive.checked,
          wholeWord: wholeWord.checked,
        };
        let hits = await findMarkersOnDoc_TEXT(query, opts);
        if (forceOCR.checked || !hits.length) {
          const ocrScale = parseFloat(ocrScaleEl.value || 2);
          const lang = (ocrLangEl.value || "eng").trim();
          const ocrHits = await findMarkersOnDoc_OCR(
            query,
            opts,
            Math.max(1, Math.min(3, ocrScale)),
            lang
          );
          const key = (h) =>
            `${h.pageIndex}:${Math.round(h.pdfX)}:${Math.round(h.pdfY)}`;
          const seen = new Set(hits.map(key));
          for (const h of ocrHits) {
            if (!seen.has(key(h))) {
              hits.push(h);
              seen.add(key(h));
            }
          }
        }
        await renderPage();
        const pageHits = hits.filter((h) => h.pageIndex === currentPage);
        if (!pageHits.length) {
          showInfo(`Trang ${currentPage}: kh√¥ng th·∫•y "${query}".`);
          return;
        }
        for (const h of pageHits)
          drawMarkerDebugBox(h.pdfX, h.pdfY, h.approxW, h.approxH);
        showInfo(
          `Trang ${currentPage}: ${pageHits.length} hit cho "${query}" (ƒë√£ highlight).`
        );
      });

      prevBtn.addEventListener("click", async () => {
        if (!pdfDoc) return;
        currentPage = Math.max(1, currentPage - 1);
        await renderPage();
      });
      nextBtn.addEventListener("click", async () => {
        if (!pdfDoc) return;
        currentPage = Math.min(pdfDoc.numPages, currentPage + 1);
        await renderPage();
      });

      zoomRange.addEventListener("input", async (e) => {
        currentZoom = parseInt(e.target.value, 10);
        zoomLabel.textContent = currentZoom + "%";
        if (pdfDoc) await renderPage();
      });
      fitBtn.addEventListener("click", async () => {
        currentZoom = 100;
        zoomRange.value = "100";
        zoomLabel.textContent = "100%";
        if (pdfDoc) await renderPage();
      });
      window.addEventListener("resize", async () => {
        if (pdfDoc) await renderPage();
      });

      // Export with pageIndex
      exportBtn.addEventListener("click", async () => {
        if (!pdfBytesOriginal) return;
        const pdfDocOut = await PDFDocument.load(pdfBytesOriginal);
        const font = await pdfDocOut.embedFont(StandardFonts.Helvetica);
        for (const a of annotations) {
          const page = pdfDocOut.getPage((a.pageIndex || 1) - 1);
          if (a.type === "rect") {
            page.drawRectangle({
              x: a.pdfX,
              y: a.pdfY,
              width: a.pdfW,
              height: a.pdfH,
              color: rgb(1, 1, 1),
            });
          } else if (a.type === "image") {
            const bytes = await fetch(a.src).then((r) => r.arrayBuffer());
            let imgEmbed;
            try {
              imgEmbed = await pdfDocOut.embedPng(bytes);
            } catch {
              imgEmbed = await pdfDocOut.embedJpg(bytes);
            }
            page.drawImage(imgEmbed, {
              x: a.pdfX,
              y: a.pdfY - a.pdfH,
              width: a.pdfW,
              height: a.pdfH,
            });
          }
        }
        const outBytes = await pdfDocOut.save();
        const blob = new Blob([outBytes], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "signed.pdf";
        a.click();
        URL.revokeObjectURL(url);
      });

      // Sample
      sampleLink.addEventListener("click", async (e) => {
        e.preventDefault();
        const ab = await fetch(
          "https://unec.edu.az/application/uploads/2014/12/pdf-sample.pdf"
        ).then((r) => r.arrayBuffer());
        const bytes = new Uint8Array(ab);
        pdfBytesOriginal = bytes.slice();
        annotations = [];
        rerenderAnnoList();
        await loadPdfFromBytes(bytes.slice());
      });
    </script>
  </body>
</html>
